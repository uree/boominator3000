package main

import (
	"strings"
    "fmt"
    "net/http"
    "encoding/xml"
	"io/ioutil"
	"time"
)


type URLSet struct {
	XMLName xml.Name `xml:urlset`
    URLSet	[]SitemapURL `xml:"url"`
}

type SitemapURL struct {
	XMLName	         xml.Name `xml:"url"`
    Location         string `xml:"loc"`
    LastModifiedDate string `xml:"lastmod"`
    ChangeFrequency  string `xml:"changefreq"`
}


func inTimeSpan(start, end, check time.Time) bool {
    return check.After(start) && check.Before(end)
}

const
(
    RFC3339     = "2006-01-02T15:04:05Z"
)

func main() {
	

    resp, err := http.Get("http://radiostudent.si/sitemap.xml?page=1")
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()
	
	fmt.Println("Response status:", resp.Status)

	byteValue, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Printf("error: %v", err)			
	}
	var urlset URLSet
    xml.Unmarshal(byteValue, &urlset)

	timeFilter, _ := time.Parse(RFC3339, "2021-06-01T15:00:01Z")
	fmt.Println("timeFilter: ", timeFilter)
	
	for i := 0; i < len(urlset.URLSet); i++ {
		loc := strings.ToLower(urlset.URLSet[i].Location)
		mod, _ := time.Parse(RFC3339, urlset.URLSet[i].LastModifiedDate)
		if strings.Contains(loc, "/glasba/tolpa-bumov/"){
			if mod.After(timeFilter) {
				fmt.Println("Location: " + urlset.URLSet[i].Location)
        		fmt.Println("Modified: " + urlset.URLSet[i].LastModifiedDate)
			} else {
				fmt.Println("Modified: ", mod)
			}
		}       
    }

}

	doc, err := goquery.NewDocumentFromReader(resp.Body)
	
	if err != nil {
		log.Fatal(err)
	}
	doc.Find("iframe").Each(func(i int, s *goquery.Selection) {
		fmt.Printf(i)
		})
	}
